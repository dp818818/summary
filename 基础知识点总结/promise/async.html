<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>
        <div>12123123</div>
    </div>

    <script>
        // async function asyncTest(){
             
        // }

        // console.log(asyncTest())  //async   asyncTest()方法就是Promise 默认是完成状态  返回值为undefined
        
        // async function asyncTest2(){
        //      return 11
        // }

        // console.log(asyncTest2())  //  asyncTest2()也是完成状态的Promise  返回值是11
        
        async function asyncTest3(){
             return 11
            //  reject()  // reject is not defined  没有reject
        }

        asyncTest3().then(res=>{
            console.log(res) // 结果是 11 因为async是Promise 并且是 成功的状态  所以走下一个回调
        })


        // async就是Promise的语法糖
        // await 取决于 Promise的 resolve 或 reject    通过try catch捕获   reject就走 catch  
        // 目的是为了Promise的链式调用  （.then）造成的回调地狱 使异步回调 变得像同步一样美观


        // function testTime(){
        //     return new Promise((resolve,reject)=>{
        //         setTimeout(e=>{
        //             console.log(1111)
        //             resolve()
        //         },1000)
        //     })
        // }  

        // function testTime2(){
        //     return new Promise((resolve,reject)=>{
        //         setTimeout(e=>{
        //             console.log(2222)
        //             resolve()
        //         },500)
        //     })
        // }  

        // async function userAsync(){
        //     try{
        //       console.log(00000)  
        //       await testTime()
        //       await testTime2()
        //       console.log(33333)  
        //     }catch(e){
        //       console.log(e)
        //     }
        //     // console.log(1111)
        // }

        // userAsync() 

    </script>
</body>
</html>